import NeuralNetwork from "../../machineLearning/NeuralNetwork"
import * as tf from '@tensorflow/tfjs';

export default class Player {
    constructor() {

        this.width = 20
        this.height = 100
        this.brain = new NeuralNetwork(4, 100, 1)
        this.fitness = 0
        this.score = 0
        this.pos = p5.createVector(20, canvasHeight / 2 - this.height / 2)
        this.vel = p5.createVector(0, 0)
        this.accel = 20
    }

    keyboardListener() {
        p5.keyPressed = () => {

            if (p5.keyCode === p5.UP_ARROW) {
                this.move(-1)
            }
            if (p5.keyCode === p5.DOWN_ARROW) {
                this.move(1)
            }
        }

        p5.keyReleased = () => {
            this.move()
        }
    }

    think() {
        const dist = ball.pos.x - this.pos.x + this.width
        const velX = ball.force.x
        const velY = ball.force.y
        const posY = ball.pos.y

        const output = this.brain.predict([dist, velX, velY, posY])

        const direction = output[0]

        if (direction > 0.666) {
            this.move(1)
        } else if (direction < 0.333) {
            this.move(-1)
        } else {
            this.move()
        }
    }

    move(direction = 0) {
        if (direction > 0 && this.pos.y < canvasHeight - this.height)
            this.vel = p5.createVector(0, direction * this.accel)
        else if (direction < 0 && this.pos.y > 0)
            this.vel = p5.createVector(0, direction * this.accel)
        else
            this.vel = p5.createVector(0, 0)
    }

    update() {
        if (this.vel.y > 0 && this.pos.y > canvasHeight - this.height) {
            return
        } else if (this.vel.y < 0 && this.pos.y < 0) {
            return
        } else {
            this.pos.add(this.vel)
        }
    }

    render() {
        // Draw ship
        p5.push()
        p5.fill(255)
        p5.stroke(255)

        p5.rect(this.pos.x, this.pos.y, this.width, this.height);

        p5.pop()
    }

    clone() {
        let player = new Player()
        player.score = this.score
        player.fitness = this.fitness
        player.brain.dispose()
        player.brain = this.brain.clone()
        return player
    }

    crossover(partner) {
        // Get NeuralNetwork layers from parents
        const parentADna = this.brain.layers_weights
        const parentBDna = partner.brain.layers_weights

        // Create a new array of layers to child's NeuralNetwork based on both parents NeuralNetwork DNA, iterating over each NeuralNetwork layer
        const childLayers = Array.from({ length: parentADna.length }, (el, i) => {
            // Get the raw weight values from actual NeuralNetwork layer
            const dnaAWeight = parentADna[i].dataSync()
            const dnaBWeight = parentBDna[i].dataSync()
            const shape = parentADna[i].shape

            // Make a new array of weights crossing over the parent NeuralNetwork DNA
            const childDna = Array.from({ length: dnaAWeight.length }, (p, i) => {
                // Random to decide if we gonna get parentA genome or parentB genome
                if (p5.random() > .5) {
                    return dnaAWeight[i]
                } else {
                    return dnaBWeight[i]
                }
            })

            // Return a new tensor with child generated DNA and same shape
            return tf.tensor(childDna, shape)
        })

        // Create the child
        let child = this.clone()
        // Dispose any existing data
        child.brain.dispose()
        child.score = 0
        child.fitness = 0
        // Override existing layers with new layers generated by crossover
        child.brain.layers_weights = childLayers

        return child
    }

    mutate() {

        // Iterate over each brain layer to mutate then
        this.brain.layers_weights = this.brain.layers_weights.map(layer => {
            // Run over each value of actual layer
            const mutated_weights = layer.dataSync().map(x => {
                // Use a random to decide the chance of this genome being mutated
                if (p5.random() < 0.05) {
                    // Apply an randomGaussian to existing genome and return it
                    let offset = p5.randomGaussian() * 0.5
                    return x + offset
                }
                // return the same genome won't modified
                return x
            })
            const shape = layer.shape

            // Dispose actual layer
            layer.dispose()
            // Return a new tensor with mutated weights and same shape
            return tf.tensor(mutated_weights, shape)
        })

    }
}